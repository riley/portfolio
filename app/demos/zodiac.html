
<!DOCTYPE html>
<html lang="en">
<head>
    <meta http-equiv="Content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>zodiac</title>

    <link rel="stylesheet" href="css/zodiac.css" type="text/css" media="screen" title="no title" charset="utf-8">


</head>
<body id="index">
    <div id="stars"></div>

    <!-- le magic -->
    <div id="controls" class="controls">
        <h1>close to home</h1>
        <p>This is a model of the real positions of the stars in the zodiac constellations. The <span class="earth">earth is the blue dot</span> in the center, the <span class="equator">blue line is the celestial equator</span>, and the <span class="ecliptic">yellow line is the ecliptic</span> (the apparent path of the sun throughout the year).</p>
        <!-- <p>The yellow <span class="alpha">star with the magenta ring</span> around it is Alpha Centauri, the closest star at 4.3 light years, or about 25.3 trillion miles.</p> -->
        <p>Obviously, <span>the sizes of the stars are not to scale.</span></p>
        <a href="#" id="lock-center">Move camera to Earth</a>
        <a href="#" style="display: none;" id="release-lock">Release camera</a>
        <ul id="constellations">
        </ul>
    </div>


<!-- shaders for stars -->
<script type="x-template" id="v-shader">
    attribute float aSize;
    attribute vec3 aColor;

    varying vec3 vColor;

    void main() {
        vColor = aColor;
        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);

        gl_PointSize = aSize * (300.0 / length(mvPosition.xyz));
        gl_Position = projectionMatrix * mvPosition;
    }
</script>

<script type="x-template" id="f-shader">
    uniform vec3 uColor;
    uniform sampler2D texture;

    varying vec3 vColor;

    void main() {
        vec4 color = vec4(uColor * vColor, 1.0) * texture2D(texture, gl_PointCoord);

        if (color.w < 0.5) discard;

        gl_FragColor = vec4(uColor * vColor, 1.0) * texture2D(texture, gl_PointCoord);
    }
</script>

<script src="js/three.min.js" type="text/javascript" charset="utf-8"></script>
<script src="js/TrackballControls.js" type="text/javascript" charset="utf-8"></script>
<script src="js/constellation_coordinates.js" type="text/javascript"></script>
<script type="text/javascript">
/* global THREE, zodiac */

var spectralMap = { // pulled from wikipedia
    'O': { color: 0x9aafff },
    'B': { color: 0xcad7ff },
    'A': { color: 0xf8f7ff },
    'F': { color: 0xfcffd3 },
    'G': { color: 0xfff2a1 },
    'K': { color: 0xfff2a1 },
    'M': { color: 0xff6151 }
};

/*
expecting

spectralClass: String 'K2III'
*/
function getStarColor(spectralClass) {
    var sClass = spectralClass.substring(0, 1);
    if ( typeof spectralMap[sClass] === 'undefined' ) { return spectralMap.M.color; }
    return spectralMap[sClass].color;
}

/*
expecting

rightAscension: String '02 07 10.29'
declination: String '+23 27 46.0'

*/
function toCartesian ( rightAscension, declination ) {

    var raDegrees = rightAscension.split(' ')
        .map(function (str) { return parseFloat(str, 10); })
        .reduce(function (m, v, i) {
            return m + v / Math.pow(60, i);
        }, 0);
    // var raHours = raCoord[0];
    // var raMinutes = raCoord[1] / 60;
    // var raSeconds = raCoord[2] / 3600;

    //var theta = ( ( raHours + raMinutes + raSeconds) * 15 ) * ( Math.PI / 180 ); // into radians.
    var theta = raDegrees * ( Math.PI / 12 );

    var decDegrees = declination.split(' ')
        .map(function (str) { return parseFloat(str, 10); })
        .reduce(function (m, v, i) {
            return m + v / Math.pow(60, i);
        }, 0);
    // var decDegrees = decCoo[rd[0];
    // var decMinutes = decCoord[1] / 60;
    // var decSeconds = decCoord[2] / 3600;

    var phi = decDegrees * ( Math.PI / 180 ); // into radians.

    return new THREE.Vector3(
        Math.cos(phi) * Math.sin(theta),
        Math.sin(phi),
        Math.cos(phi) * Math.cos(theta)
    ).normalize();
}

function Zodiac() {

}

Zodiac.prototype.init = function () {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', 'data/stars.json');
    xhr.onload = function () {
        if (xhr.status === 200) {
            this.stars = JSON.parse(xhr.responseText);
            this.engineSetup();
            this.populateStars();
            this.populateLines();
            this.render();
            this.animate();
        } else {
            // show error message
        }
    }.bind(this);
    xhr.send(null);
};

Zodiac.prototype.engineSetup = function () {
    this.el = document.getElementById('stars');
    this.scene = new THREE.Scene();

    this.camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 10000);
    this.camera.position.z = 300;

    this.controls = new THREE.TrackballControls(this.camera);
    this.controls.rotateSpeed = 1.0;
    this.controls.zoomSpeed = 1.2;
    this.controls.panSpeed = 0.8;

    this.controls.noZoom = false;
    this.controls.noPan = false;

    this.controls.staticMoving = true;
    this.controls.dynamicDampingFactor = 0.3;

    this.controls.keys = [65, 83, 68];

    this.controls.addEventListener('change', this.render.bind(this));

    this.renderer = new THREE.WebGLRenderer({antialias: false});
    this.renderer.setClearColor('#181818');
    this.renderer.setPixelRatio(window.devicePixelRatio);
    this.renderer.setSize(window.innerWidth, window.innerHeight);

    this.el.appendChild(this.renderer.domElement);

    window.addEventListener('resize', this.onWindowResize.bind(this));
};

Zodiac.prototype.populateStars = function () {
    console.log('this.stars', this.stars);

    this.attributes = {
        aSize: {type: 'f', value: []},
        aColor: {type: 'c', value: []}
    };

    this.uniforms = {
        amplitude: {type: 'f', value: 1.0},
        uColor: {type: 'c', value: new THREE.Color(0xffffff)},
        texture: {type: 't', value: THREE.ImageUtils.loadTexture('images/white.png')}
    };

    this.uniforms.texture.value.wrapS = this.uniforms.texture.value.wrapT = THREE.RepeatWrapping;

    var shaderMaterial = new THREE.ShaderMaterial({
        uniforms: this.uniforms,
        attributes: this.attributes,
        vertexShader: document.getElementById('v-shader').textContent,
        fragmentShader: document.getElementById('f-shader').textContent,
        transparent: true
    });

    var geometry = new THREE.Geometry();

    geometry.vertices = this.stars.map(function (star) {
        var v = toCartesian(star.ra, star.dec);
        v.multiplyScalar(star.dist);
        return v;
    });

    // var geometry = new THREE.SphereGeometry(100, 68, 38);
    var sphere = new THREE.PointCloud(geometry, shaderMaterial);

    for (var v = 0; v < sphere.geometry.vertices.length; v++) {
        this.attributes.aSize.value[v] = v / 100;
        this.attributes.aColor.value[v] = new THREE.Color(0xffffff);
        this.attributes.aColor.value[v].setHex(getStarColor(this.stars[v].spec));
    }

    this.scene.add(sphere);
};

Zodiac.prototype.populateLines = function () {
    var lMaterial = new THREE.LineBasicMaterial({
        color: 0xffffff, 
        opacity: 1,
        lineWidth: 3,
        vertexColors: THREE.VertexColors
    });

    var list = document.getElementById('constellations');

    // create zodiac constellation lines
    Object.keys(constellations).forEach(function (c) {
        var geo = new THREE.Geometry();

        geo.vertices = constellations[c].shapePath.map(function (path) {
            return toCartesian(path.ra, path.dec).multiplyScalar(path.dist);
        });

        geo.colors = constellations[c].shapePath.map(function (path) {
            return new THREE.Color(0xffffff * Math.random())
        })

        var line = new THREE.Line(geo, lMaterial);
        this.scene.add(line);


        list.insertAdjacentHTML('beforeend', '<li class="zodiac-sign">' + c + '</li>');

    }, this);
}

Zodiac.prototype.animate = function () {
    requestAnimationFrame(this.animate.bind(this));
    this.controls.update();
};

Zodiac.prototype.render = function () {
    this.attributes.aSize.needsUpdate = true;

    this.renderer.render(this.scene, this.camera);
};

Zodiac.prototype.onWindowResize = function () {
    this.camera.aspect = window.innerWidth / window.innerHeight;
    this.camera.updateProjectionMatrix();

    this.renderer.setSize(window.innerWidth, window.innerHeight);

    this.controls.handleResize();

    this.render();
}

var z = new Zodiac();
z.init();

</script>
</body>
</html>